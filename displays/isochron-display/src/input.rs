//! Input handling traits and types
//!
//! Provides abstraction for different input methods (encoder, touch, buttons).

/// Navigation events from input devices
///
/// These events are hardware-agnostic and can be generated by:
/// - Rotary encoder (turn = scroll, press = select)
/// - Touch screen (swipe = scroll, tap = select)
/// - Buttons (up/down buttons, enter button)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[cfg_attr(feature = "defmt", derive(defmt::Format))]
pub enum NavigationEvent {
    /// Scroll up (encoder CCW, swipe up, up button)
    ScrollUp,
    /// Scroll down (encoder CW, swipe down, down button)
    ScrollDown,
    /// Select current item (encoder press, tap, enter button)
    Select,
    /// Go back to previous screen (long press, back button, edge swipe)
    Back,
    /// Long press on select (for entering edit mode, etc.)
    LongSelect,
    /// Increment value (in edit mode)
    Increment,
    /// Decrement value (in edit mode)
    Decrement,
}

/// Input source trait
///
/// Implemented by hardware-specific input handlers (encoder, touchscreen, etc.)
pub trait InputSource {
    /// Poll for a navigation event
    ///
    /// Returns `Some(event)` if an event occurred, `None` otherwise.
    /// Non-blocking - should return immediately.
    fn poll(&mut self) -> Option<NavigationEvent>;

    /// Check if input is currently pressed/active
    fn is_active(&self) -> bool;
}

/// Encoder state for tracking rotation
#[derive(Debug, Clone, Copy, Default)]
pub struct EncoderState {
    /// Last known A pin state
    pub last_a: bool,
    /// Last known B pin state
    pub last_b: bool,
    /// Accumulated position (can be negative for CCW)
    pub position: i32,
    /// Button pressed state
    pub button_pressed: bool,
    /// Timestamp of last button press (for long press detection)
    pub button_press_time: u64,
}

impl EncoderState {
    /// Create a new encoder state
    pub fn new() -> Self {
        Self::default()
    }

    /// Update state from pin readings and return any resulting event
    ///
    /// # Arguments
    /// * `a` - Current A pin state
    /// * `b` - Current B pin state
    /// * `button` - Current button state (true = pressed)
    /// * `current_time_ms` - Current time in milliseconds
    ///
    /// # Returns
    /// Navigation event if state change detected
    pub fn update(
        &mut self,
        a: bool,
        b: bool,
        button: bool,
        current_time_ms: u64,
    ) -> Option<NavigationEvent> {
        // Handle rotation via quadrature decoding
        let event = if a != self.last_a {
            if a == b {
                self.position += 1;
                Some(NavigationEvent::ScrollDown)
            } else {
                self.position -= 1;
                Some(NavigationEvent::ScrollUp)
            }
        } else {
            None
        };

        self.last_a = a;
        self.last_b = b;

        // Handle button
        if button && !self.button_pressed {
            // Button just pressed
            self.button_pressed = true;
            self.button_press_time = current_time_ms;
            return event; // Return rotation event if any, button event on release
        } else if !button && self.button_pressed {
            // Button released
            self.button_pressed = false;
            let held_ms = current_time_ms.saturating_sub(self.button_press_time);
            if held_ms > 500 {
                return Some(NavigationEvent::LongSelect);
            } else {
                return Some(NavigationEvent::Select);
            }
        }

        event
    }
}
